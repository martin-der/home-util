

def homeutilProjectDir = "${project.projectDir}/.."

def trimStart = {
	def start = "${project.projectDir}"
	it.startsWith(start) ? it.substring(start.size()) : it
}

def sourceDir = 'script'

def testsCount = 0
def failedTests = []


task allTests() {
	doLast {
		logger.info("Executed $testsCount test(s).")
		def failedTestsCount = failedTests.size()
		if (failedTestsCount>0) {
			logger.error("Some test(s) failed :")
			failedTests.each { logger.error("  - $it") }
			throw new GradleException("$failedTestsCount / $testsCount failed")
		} else
			logger.info("All tests succeeded")

	}
}

def sourceDirectory = file("$sourceDir")
sourceDirectory.eachFileRecurse(groovy.io.FileType.FILES) {
	script ->
		def isTest = script.name.endsWith('.sh') && !script.name.equals("common.sh") && !script.name.equals("runner.sh")
		if(isTest) {

			testsCount++

			def trimmedStart = "${project.projectDir}/script/"
			def filename = "$script".startsWith(trimmedStart) ? "$script".substring(trimmedStart.size()) : "$file"

			task "performTest_$filename" (type: Exec) {
				workingDir homeutilProjectDir
				commandLine 'bash', "$script"
				ignoreExitValue true
				standardOutput new LogOutputStream(logger, LogLevel.INFO)
				errorOutput    new LogOutputStream(logger, LogLevel.ERROR)
				doLast {
					logger.info("[Tested '$filename' :  $execResult]")
					if(execResult.exitValue != 0) {
						failedTests << "$filename"
					}
				}
			}

			allTests.dependsOn("performTest_$filename")
		}
}

class LogOutputStream extends ByteArrayOutputStream {

	private final Logger logger;
	private final LogLevel level;

	LogOutputStream(Logger logger, LogLevel level) {
		this.logger = logger;
		this.level = level;
	}

	public Logger getLogger() {
		return logger;
	}

	public LogLevel getLevel() {
		return level;
	}

	@Override
	public void flush() {
		logger.log(level, toString());
		reset();
	}
}


